Top 3 stories with the highest scores:
Story ID: 40172033, Title: Leaving Rust gamedev after 3 years, Score: 1345
Story ID: 40160429, Title: FCC votes to restore net neutrality rules, Score: 980
Story ID: 40151952, Title: You are what you read, even if you don't always remember it, Score: 833

Stories with comments on the story with the highest score:
Story ID: 40172033, Title: Leaving Rust gamedev after 3 years, Score: 1345
Comment ID: 40172273, Comment Text: I would love to be able to bypass the orphan rule for internal crates., Comment Author: maximilianburke
Comment ID: 40172284, Comment Text: &gt; The problem you&#x27;re having is only a problem because you haven&#x27;t tried hard enough.<p>You just need to read another 50,000 word fasterthanlime essay. Then you&#x27;ll not have problems any more.<p>&gt; That being said, there is an overwhelming force in the Rust community that when anyone mentions they&#x27;re having problems with Rust the language on a fundamental level, the answer is &quot;you just don&#x27;t get it yet, I promise once you get good enough things will make sense&quot;.<p>Not only this, but they openly mock other language communities for not drinking the koolaid.<p>I like Rust, and the Rust community, and fasterthanlime, for what it&#x27;s worth. But I think these points raised in the article are very much valid., Comment Author: HL33tibCe7
Comment ID: 40172314, Comment Text: The thing that the Rust community thinks sets them apart (their community), is really the thing holding them back., Comment Author: syndicatedjelly
Comment ID: 40172316, Comment Text: Has there been any progress towards shipping Rust on consoles? I know the specifics are all under NDA, but to my knowledge nobody has even hinted that they&#x27;ve done it yet, even among the studios which are openly using Rust for backend or tooling stuff (e.g. Embark and Treyarch).<p>OP only appears to release their games on PC so it&#x27;s not a concern for them, but for the majority of developers not being able to fit into console toolchains would be an immediate dealbreaker. I have no first hand information but what I&#x27;ve <i>heard</i> from hanging around people who would know is that Sony insists that developers only use their official LLVM&#x2F;Clang fork which is customised for their weird ABI., Comment Author: jsheard
Comment ID: 40172321, Comment Text: &gt; Making a fun &amp; interesting games is about rapid prototyping and iteration, Rust&#x27;s values are everything but that<p>I feel like this is the core of the author&#x27;s frustration.<p>Rust is a systems language. It&#x27;s for writing tight fast C-like code but safely and with a much more powerful type system.<p>The facilities you need to do this are somewhat at odds with what you want for rapid iteration.<p>Seems like Rust was the wrong tool for the job., Comment Author: api
Comment ID: 40172338, Comment Text: Rust is the &quot;frontend wave&quot; of the backends. All the woke kids gravitate towards it. A suffix of &quot;Written in Rust&quot; is a thing here so I&#x27;m throwing away my internet points now., Comment Author: chimen
Comment ID: 40172348, Comment Text: tl;dr -- Rust is not the language for startups who want fast iterations and are still finding it&#x27;s pmf. It is perfect for rewrites of popular system software which already has millions of users and running in production because once a software becomes mature and at million user scale, safety and security becomes paramount, Comment Author: zooq_ai
Comment ID: 40172414, Comment Text: &gt; I&#x27;d argue as far as maintainability being the wrong value for indie games, as what we should strive for is iteration speed.<p>That seems to be the crucial point. Rust is optimized for writing complex systems software in large teams. That’s not a great fit for a small team hacking on something that is at least in part an art  project. You wouldn’t choose something like Ada for that either., Comment Author: adrianN
Comment ID: 40172435, Comment Text: The Rust community is one of the top arguments against rust.<p>I&#x27;ve never before been so condescended to as when attempting to ask questions there. Their lack of care for perf also drives me up a wall. Anytime they propose adding an extra layer of indirection to get around the borrow checker, I have to explain yet again that with the way modern CPUs work, extra layers of indirection have serious cache-related perf costs. Then I get told that I am yet again doing it wrong, computers are fast enough, and I am worrying about the wrong thing., Comment Author: dmitrygr
Comment ID: 40172436, Comment Text: Unity is so good and quite affordable, basically there’s zero upfront risk of using it. Similar for Unreal Engine. And then there are tons of other open-source engines like Godot that are also quite good.<p>Rust is great from lots of stuff but game development or building UIs isn’t among that (yet)., Comment Author: throwaway63467
Comment ID: 40172449, Comment Text: As much as I love Rust I sometimes wonder if I&#x27;d be more productive in a simpler language. If I wrote it every day I&#x27;m not sure that would be true, but as a hobbyist coming back to Rust sometimes takes me a bit to get back in the zone. Also, still not a fan of async, as it is woefully incomplete and fairly complicated in some use cases. That said, I just can&#x27;t go back to Go with nil pointers and lack of decent enums&#x2F;ADTs&#x2F;pattern matching either. I long for the &quot;in between&quot; language, but with an amazing 3rd party ecosystem as both Rust&#x2F;Go have.<p>NOTE: I&#x27;m not a game dev, Comment Author: nu11ptr
Comment ID: 40172457, Comment Text: Like the author states, the &quot;written in Rust&quot; bonus many projects get does not apply to games. Most of the games I consider to be the most fun are built on an absolute rats nest dumpster fire of code (see: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=k238XpMMn38" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=k238XpMMn38</a>). Sometimes bugs even expand game mechanics and make them more fun and expressive. That being said I&#x27;ll definitely check out Unrelaxing Quacks, it looks great., Comment Author: bfors
Comment ID: 40172473, Comment Text: My impression of Rust is that it&#x27;s a very opinionated language that wants everybody to program in a specific way that emphasizes memory safety above everything. That&#x27;s a good idea, I think, for the systems programming use cases that it was intended for. I don&#x27;t see that as a particularly useful thing to value for game development. The part in the article about the Rust borrow checker constantly forcing refactors sounds extremely obnoxious to deal with.<p>I&#x27;d think that an ideal game dev language would be programmer time efficient, reasonably performant and designed for skilled programmers who can handle a language filled with footguns. Basically a better version of C such as a selective subset of C++ or a Golang without garbage collection. I just don&#x27;t think the kinds of security bugs you get from C&#x2F;C++ &quot;unsafe&quot; code are that big of a deal for games but they would be for a web site or an enterprise database., Comment Author: bdw5204
Comment ID: 40172490, Comment Text: This is a very brave post to write given how incendiary responses to rust criticism can be, but this matches my experience entirely., Comment Author: ninepoints
Comment ID: 40172491, Comment Text: This article describes almost exactly why I think gradual typing is actually a good thing. Type checkers shouldn&#x27;t get in the way of your code compiling. Yes, the language has to be designed with this property from the beginning. Yes, you should always enforce complete checking in CI. But you should also be able to try half-baked ideas., Comment Author: telekid
Comment ID: 40172522, Comment Text: All low-level languages (by which I mean languages that offer control over all&#x2F;most memory allocation) inherently suffer from low abstraction, i.e. there are fewer implementations of a particular interface or, conversely, more changes to the implementation require changes to the interface itself or to its client [1]. This is why even though writing a program in many low-level languages can be not much more expensive than writing the program in a high-level language (one where memory management is entirely or largely automatic), costs accrue in maintenance.<p>Now, a language like Rust makes some aspects better because it ensures that the maintenance (refactoring) is done correctly -- reducing the risk of mistakes -- but it comes at a cost: you must explain your handling of memory (before and after the refactor) to the compiler (plus, the compiler doesn&#x27;t understand all patterns). I think it&#x27;s too soon to empirically compare this cost to the gain in reduced risk and determine when each option is more or less advantageous (and perhaps it is also a matter of personal programmer preference), the fact remains that maintenance of programs in all low-level languages is always more costly than maintenance of programs written in high-level languages because of the low abstraction inherent to all low-level languages.<p>When writing in a low-level language some may prefer the Rust approach while others may prefer less restrictive ones [2], but people choosing any low-level language should be aware of the added maintenance cost they&#x27;re invariably signing up for. Sadly, this cost only becomes apparent at later stages of the project.<p>[1]: Some people claim that memory is just like any other resource (e.g. file descriptors), but this is incorrect. Memory and processing are fundamental to the very nature of abstract algorithms, and differences in how memory is handled change the available range of algorithms. E.g. finite state machines, queue automata, and Turing machines differ only in how memory is handled and accessed. In short -- memory and processing are special resources and are not the same as IO resources.<p>[2]: I&#x27;m personally not a big fan of Rust&#x27;s approach -- and I particularly dislike C++&#x27;s and Rust&#x27;s &quot;zero-cost abstraction&quot;, which is the attempt to make the low abstraction ability invisible in the final code without changing its fundamental aspects -- but I recognise that people&#x27;s opinions differ on this matter. I also reject the claim that there&#x27;s no middle ground between Rust and C that offers an intermediate tradeoff between them, i.e. that there is no safety premium to a language that offers some of Rust&#x27;s safety guarantees but not all of them, such as Zig, or offers better and effective assurance of some properties without a sound guarantee., Comment Author: pron
Comment ID: 40172523, Comment Text: Do they say what they replaced Rust with? I scanned through a few times and couldn&#x27;t figure it out., Comment Author: mtlynch
Comment ID: 40172526, Comment Text: <i>&gt; games are single threaded.</i><p>Huh. Not games like Cyberpunk 2077 and it&#x27;s good that they are not., Comment Author: shmerl
Comment ID: 40172577, Comment Text: &gt; Making a fun &amp; interesting games is about rapid prototyping and iteration, Rust&#x27;s values are everything but that<p>I found this to be true of C after many, many years coding in C. I noticed that the first selection of data layout stayed throughout the life of the code (with a lot of tweaks, additions, etc.). But didn&#x27;t really think that much about it.<p>Until I started writing code in D. It was easy to change the data layout, and I did for experimenting. For example, changing a reference type to a value type, and vice versa. This was easy in D. It&#x27;s just too much work in C, so it didn&#x27;t happen.<p>The reason is simple:<p><pre><code>    p-&gt;b
    v.b
</code></pre>
To switch between a ref and a value type, you&#x27;ve got to search&#x2F;replace the -&gt; into ., and the . into -&gt;, and not disturb the dots and arrows of the other types. When dealing with 100,000 lines of code, this is a non-starter.<p>But with D, both reference and value types are used as:<p><pre><code>    p.b
    v.b
</code></pre>
making it easy to switch between the two, and also switching function parameters from values back and forth with references., Comment Author: WalterBright
Comment ID: 40172590, Comment Text: Gaming is C++ first and foremost. All other languages suck, except when used to script game engines (C# in Unity, etc.). There&#x27;s no practical reason to choose Rust or anything else. I don&#x27;t think Rust is particularly bad or good here. There&#x27;s decades of work to catch up on. I don&#x27;t see Rust becoming a truly great language for games unless it&#x27;s blessed by Epic or Unity., Comment Author: tormeh
Comment ID: 40172593, Comment Text: &gt; Rust gamedev ecosystem lives on hype<p>I&#x27;ve been saying this for years. I&#x27;ve tried to get into Rust multiple times the past few years and one of the things I&#x27;ve tried was gamedev with Rust (specifically the library ggez when it was still being worked on, and a little bit of Bevy). I admittedly never got far, but I gave it a solid shot.<p>My experience was instantly terrible. Slow compile times and iterations, huge package downloads (my project folder was roughly 1gb for a simple 2D project), and of course Rust itself was difficult to get into with lifetimes and having to wrap and unwrap my variables constantly and getting into wrestling matches with the borrow checker.<p>I kept telling myself that everyone loves Rust and the community loves to rave about anything Rust-related and maybe I just don&#x27;t get it, but it took some time to realize that no... It&#x27;s just a terrible choice for it. I even tried to make UI with eGUI and was still miserable. Rust is a systems programming language but the community is trying to convince everyone should be used for general purpose stuff.<p>And my other biggest problem is that they keep painting other non-Rust things as being fundamentally flawed for not being Rust. &quot;It&#x27;s not memory safe&quot; is the biggest one thrown around, but when was the last time memory safety was actually a big problem in games? Unity uses C# which is garbage collected, Godot uses its own scripting language which makes it nigh impossible to leak memory, Unreal AFAIK has its own tools that makes memory management trivial. Rust game development feels like a solution looking for a problem to fix.<p>I am curious about Bevy when it becomes mature and has its own editor, but for now I&#x27;m just not convinced gamedev with Rust will ever take off., Comment Author: popcar2
Comment ID: 40172604, Comment Text: I find that Jonathan Blow ranting about Rust game development here <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4t1K66dMhWk" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=4t1K66dMhWk</a>. He adds interesting perspectives to the discussio, how the language makes the Rust game developer resort to arrays and their so called Rust point of views., Comment Author: colund
Comment ID: 40172613, Comment Text: &amp;str vs String. Oh boy., Comment Author: klaussilveira
Comment ID: 40172636, Comment Text: &gt; Orphan rule should be optional<p>That has got to be the most &quot;I didn&#x27;t think this through&quot;  take ever.<p>While it&#x27;s a known pain in the ass. Not having it is a bigger pain.<p>The moment you allow this, you have to find a way to pick between several implementation - and they don&#x27;t always have sane names.<p>Orphan rules prevent this from happening., Comment Author: Ygg2
Comment ID: 40172682, Comment Text: That logo is huge on mobile so I can&#x27;t read the first few bullet points., Comment Author: desiderantes
Comment ID: 40172704, Comment Text: Starting by saying I fundamentally agree wrt iteration speed. This is ultimately why [C&#x2F;C++]&#x2F;Lua was such a thing for a while, and it seems quite plausible that you could benefit from a core engine in rust bound to a scripting language.<p>But ultimately I sense the subtext here is much the same as with other Rust problems: the object oriented baby has been thrown out with the bathwater, often in the name of premature optimisation, but also with a sense of misplaced religious purity regarding the evils of state and the merits of functional programming. There never was any OOP law that your inheritance hierarchy had to be insane, or that you had to create classes for absolutely every last thing. Now we have people hitting the opposite extreme where everything has to go through the same function switched on a pattern matched enum. One of the core problems with Rust is it lacks the mechanisms to allow moving adequately out of this tarpit.<p>I still think Rust might have a place at the lowest level core where it is all about shuffling arrays of things through compute units, but for the higher level pieces it is clearly the wrong thing to be using., Comment Author: fidotron
Comment ID: 40172706, Comment Text: Oh we’re at that point of the hype cycle are we?, Comment Author: blowski
Comment ID: 40172711, Comment Text: In my experience, fundamentally when you&#x27;re starting a software project, you need to make a strong up-front decision between two things:<p>1. I am using technology in order to build this thing.<p>2. I am building this thing in order to use this technology.<p>Developers often fall in the (2) camp but don&#x27;t admit it. There&#x27;s an allure to using the new, sexy tech that will solve all their problems, whether that&#x27;s Rust, Kubernetes, LLMs, etc.<p>If you&#x27;re in the (1) camp, you should stick with what you know; and if you know that what you know isn&#x27;t enough to build the thing, you should use whatever is most common and straightforward, not something off the beaten path.<p>Games seem to be the biggest trap, because solo devs often end up building a game <i>engine</i> when they set out to build a game. If you really want to build a game, just use Unity&#x2F;Unreal&#x2F;Godot, I promise it&#x27;ll go better for you., Comment Author: mjr00
Comment ID: 40172738, Comment Text: Interesting to me to have [iteration speed] &lt;--&gt; [maintainability] spelled out as opposite ends of a spectrum... and that sometimes [iteration speed] is the right thing to optimize for., Comment Author: nielsbot
Comment ID: 40172745, Comment Text: OP should give D a try, my game fully recompile in less than 1sec, and i can consume most of the C gamedev ecosystem without effort and seamlessly, Comment Author: WhereIsTheTruth
Comment ID: 40172747, Comment Text: I&#x27;ve done hobby gamedev in Bevy&#x2F;Rust, Godot&#x2F;C#, and Unity C#.<p>It&#x27;s honestly somewhat baffling to me that folks will choose Rust for gamedev right now. The state of the open sourced tools are just not there yet, especially when compared to Godot, and at the same time these games are running on PC hardware which tends to get faster every year.<p>Also for ECS... one thing I tended to realize is that when developing a game, pigeonholing everything into an ECS can seriously tend to get in the way. A lot of (efficiently written) game code is best handled in an infrequent event-driven way.<p>An ECS backed game engine like Bevy can make big mobs more efficient, but few games will actually leverage this effectively for fun gameplay and at the same time modern PCs are fast as hell.<p>I think about Starcraft from 1998, created when virtually all PCs only had one core, and its 200 unit per faction cap. Blizzard hasn&#x27;t increased this cap because it doesn&#x27;t necessarily make the game more fun. Now should a gamedev today, 26 years later, making a 2d isometric game for the PC be worried about performant multithreading????, Comment Author: LarsDu88
Comment ID: 40172794, Comment Text: &gt; As far as a game is concerned, there is only one audio system, one input system, one physics world, one deltaTime, one renderer, one asset loader.<p>I thought this way when I was doing Java dev around 10 years ago.  I thought it excused the singleton pattern.  I was wrong!<p>You should always be able to construct an object by explicitly passing dependencies to it.  Especially for testing.<p>It really is no fun if your renderer starts talking to your asset loader and timer directly., Comment Author: mrkeen
Comment ID: 40172832, Comment Text: I agree with a lot here, but I think the author is overplaying &quot;get things done fast&quot; or underplaying &quot;stable, performant code&quot;.  I like indie games, but I&#x27;ve played enough games that crashed if I look at them wrong or chug despite being low poly early 2000s things that I now hesitate to buy indie games. Some of the examples seemed like maybe rust was preventing a weird unexpected feedback or clobbering iteration state or whatever.<p>I don&#x27;t think the author disagrees here and is mostly talking about awful runtime alternatives (refcell, etc) but I just wanted to say it for balance., Comment Author: rendaw
Comment ID: 40172848, Comment Text: Honestly I have not read all the article. What language they are going to use instead of Rust?, Comment Author: fbn79
Comment ID: 40172864, Comment Text: This is a sobering read. Thank you for sharing.<p>This sums it up for me:<p>&gt; Rust as both language and community is so preoccupied with avoiding problems at all cost that it completely loses sight of what matters, delivering an experience that is so good that whatever problems are there aren&#x27;t really important. This doesn&#x27;t mean &quot;ship crap games&quot;, it means focusing on the game being a good game, not on the code being good code.<p>I think this can be easily extrapolated to projects outside of game development as well.<p>User experience is ultimately all that matters. If you&#x27;re in prototyping stages of whatever it is you&#x27;re building, and games spend a lot of time in this phase, then your focus should always be on testing what the user experience will be like, rather than absolute code correctness, maintainability, and everything else that makes a long-term project successful.<p>The fact Rust seemingly can&#x27;t deliver this rapid prototyping workflow should be a large factor when deciding which language to use.<p>I&#x27;ve been using Go as my main language for the better part of a decade now, and I think it strikes the perfect balance of code quality and rapid prototyping. It&#x27;s far from the side of absolute freedom of a language like Python, which becomes a nightmare to work with after the prototyping phase is over (though this might have improved in the past few years), but it&#x27;s also far from languages like Rust, and allows me to be very productive, very quickly, while also being easy to pick up for newcomers. I probably wouldn&#x27;t pick it for GUI or game development either, though, but for things like CLI, network and web tooling, it&#x27;s perfect., Comment Author: imiric
Comment ID: 40172874, Comment Text: Absolutely agree with the comments on ECS and Bevy in particular. I tried getting to grips with it for some time, doing things the Bevy way, and it just felt like a big step backwards because it’s not suitable for most things. The renderer was really slow at the time too, although I imagine that has improved. Switched to plain rust + vulkan (via ash) + dear imgui and haven’t looked back., Comment Author: attheicearcade
Comment ID: 40172901, Comment Text: <p><pre><code>   By the time the Rust developer is finished with their refactoring, the C++&#x2F;C#&#x2F;Java&#x2F;JavaScript developer has implemented many different gameplay features, played the game a bunch and tried them all out, and has a better understanding of which direction should their game be taking.
</code></pre>
Man, slower than C++, that&#x27;s pretty damning., Comment Author: npalli
Comment ID: 40172947, Comment Text: As someone in a similar position (also ~3 years doing gamedev in Rust but only free time + open source), I feel very similarly.<p>There&#x27;s low hanging fruit i&#x27;ve been complaining about for years where Rust is protecting us from ourselves - orphan rules, global state, ... Look, we&#x27;re adults, we can make decisions with tredeoffs.<p>Compile times are a tougher one, I understand that Rust does analysis that is more complex than many langs and i feel ungrateful to people who spend their free time improving Rust. But also i don&#x27;t think the complexity justifies all of it. Make dynamic linking easier, reduce how much needs to be recompiled, compile generics to dynamic dispatch in debug builds, etc. - there&#x27;s gotta be a ton of stuff that can investigated.<p>ECS just plain sucks. People use it because what they want at first is some way to have relationships between entities. References&#x2F;pointers are the obvious solution in most langs but in rust, they&#x27;re obviously out. The second option is Vec and indices but that falls apart as soon as you start removing entities. The next step up the ladder of complexity should be generational arenas but for some reason people immediately reach for the big guns - ECS. And it infests their game with two things that make gamedev a slog - dynamic typing and boilerplate.<p>Boilerplate is obvious to anyone who has done gamedev the &quot;obvious&quot; way before. What could be projectile.shooter.score += 1 is multiple lines which (depending on your particular choice of ECS) usually involve generics. You shift your focus from tweaking your game logic and tuning the experience to typing out boiletplate.<p>Dynamic typing means entities are no longer structs with fields where you can understand how they relate to each other at a glance but instead any component can be anywhere, entities are no longer real, refactoring always causes silent bugs.<p>However, by far the biggest issue is the community&#x27;s handling of criticism.<p>There are practically no experienced gamedevs coming to Rust from other langs so there&#x27;s nobody to give Rustaceans a reality check. Rust gamedevs are almost always writing their first game (or, yes, engine). And there&#x27;s nothing wrong with that, i was writing my first game at one point too. But their attitude is that they chose Rust because they heard it&#x27;s the best and they got invested in the language because it&#x27;s hard(er) to learn and now with all this investment if they hear rust or their particular favorite engine might not be that great, it feels like wasted effort so they get emotional and defensive.<p>I&#x27;ve personally chatted with over half a dozen other gamedevs who came to rust with years of experience under their belt and a common pattern is that they avoid the rust (gamedev) community because they&#x27;re beat down by the negativity heaped upon them every time they try to discuss the negatives. It doesn&#x27;t matter they take every effort to offer constructive criticism, it becomes a social instead of technical topic.<p>I came to Rust because i care about code correctness and, well, quality (of tooling, docs, testing). And Rust delivers there on a lot of that. But i also wanted to write games of a larger scale than can be done in one person. My hope was that there&#x27;d be other people with the same values who wanna build cool games together. Instead there&#x27;s a low single digit number of serious open source projects and a bunch of small one man games and a a whole lot of loud people who seem to think gamedev is about hyping up an engine like it&#x27;s a sports team.<p>Myself, I apparently chose the wrong engines for my games in both cases. Not because they&#x27;re bad technically. In fact, having 5 years of gamedev experience before Rust, i think my choices are better from a technical perspective but there&#x27;s just not the critical mass to build a serious open source game around them., Comment Author: martin-t
Comment ID: 40172952, Comment Text: That&#x27;s a good article. He&#x27;s right about many things.<p>I&#x27;ve been writing a metaverse client in Rust for several years now. Works with Second Life and Open Simulator servers. Here&#x27;s some video.[1] It&#x27;s about 45,000 lines of safe Rust.<p>Notes:<p>* There are very few people doing serious 3D game work in Rust. There&#x27;s Veloren, and my stuff, and maybe a few others. No big, popular titles. I&#x27;d expected some AAA title to be written in Rust by now. That hasn&#x27;t happened, and it&#x27;s probably not going to happen, for the reasons the author gives.<p>* He&#x27;s right about the pain of refactoring and the difficulties of interconnecting different parts of the program. It&#x27;s quite common for some change to require extensive plumbing work. If the client that talks to the servers needs to talk to the 2D GUI, it has to queue an event.<p>* The rendering situation is almost adequate, but the stack isn&#x27;t finished and reliable yet. The 2D GUI systems are weak and require too much code per dialog box.<p>* I tend to agree about the &quot;async contamination&quot; problem. The &quot;async&quot; system is optimized for someone who needs to run a very large web server, with a huge number of clients sending in requests. I&#x27;ve been pushing back against it creeping into areas that don&#x27;t really need it.<p>* I have less trouble with compile times than he does, because the metaverse client has no built-in &quot;gameplay&quot;. A metaverse client is more like a 3D web browser than a game.
All the objects and their behaviors come from the server.
I can edit my part of the world from inside the live world.  If the color or behavior or model of something needs to be changed, that&#x27;s not something that requires a client recompile.<p>The people using C# and Unity on the same problem are making much faster progress.<p>[1] <a href="https:&#x2F;&#x2F;video.hardlimit.com&#x2F;w&#x2F;7usCE3v2RrWK6nuoSr4NHJ" rel="nofollow">https:&#x2F;&#x2F;video.hardlimit.com&#x2F;w&#x2F;7usCE3v2RrWK6nuoSr4NHJ</a>, Comment Author: Animats
Comment ID: 40173005, Comment Text: Zig zig zig zig zig :D, Comment Author: overflyer
Comment ID: 40173006, Comment Text: Rust being the best alternative to C++ is why I&#x27;m wildly rooting for Mojo. This language sacrifices a lot in ergonomics and UX to the alter of safety. And the Rust community never fails to interject with &quot;Well, Akshually...&quot; whenever you complain., Comment Author: melodyogonna
Comment ID: 40173038, Comment Text: I&#x27;ve been thinking of embarking on a Rust&#x2F;GUI&#x2F;Game.  Guess, this will save some grief.  Is Rust the future?  Will this situation improve?  I&#x27;ve been wanting to like Rust, but this seems to be indictment., Comment Author: FrustratedMonky
Comment ID: 40173050, Comment Text: I see some of those things could perhaps be solved by implementing parts of the game in a sandbox. I know that&#x27;s work: I&#x27;m doing it myself. But all the work with the host-guest boundary (let&#x27;s not call it bindings, please), is worth it in the end.<p>I have a C++ game client, a C++ game server, and a shared C++ game script that is transferred to all clients, running in a RISC-V emulator. That means the script will fundamentally execute the same way on all clients, and the server. I have no idea what everyone else is doing. This is what I&#x27;m doing now, and the more fleshed out it&#x27;s becoming, the more I actually like it this way. I don&#x27;t think I could easily &quot;go back&quot; to other solutions., Comment Author: fwsgonzo
Comment ID: 40173252, Comment Text: Rust... what is it good for? 
&quot;Systems programming&quot; ...<p>Rust is not good for raw performance.
Neither for prototyping and iteration.<p>Personally I think operating systems (kernels) should be as performant as possible, and C&#x2F;C++ has been good enough for decades.<p>Anyone really unhappy with Linux&#x2F;BSD&#x2F;Windows&#x2F;macOS performance?<p>What systems are we talking about that benefits from Rust?
Advanced weapon systems that should absolutely not fail? 
Controllers for air planes? Traffic controllers? Radar?
Power grid?<p>Google, fb, amazon, etc. use C&#x2F;C++ to squeeze the most performance out of anything I&#x2F;O heavy, and security is not an issue that deep in the stack, that&#x27;s not the exploitation layer., Comment Author: erikbye
Comment ID: 40173279, Comment Text: I&#x27;ve become wary of commenting on articles that mention the pros and cons of various languages, but I still find it strange that so many people are so strongly focused on what their favourite language can do (usually better than others), instead of the project they&#x27;re working on. When it should be the other way around.<p>The joke he mentioned about having 50 engines written but only 5 games certainly rings true and I don&#x27;t think the language is the main problem preventing people from getting their projects done.., Comment Author: indigoabstract
Comment ID: 40173356, Comment Text: &gt; The most fundamental issue is that the borrow checker forces a refactor at the most inconvenient times. Rust users consider this to be a positive, because it makes them &quot;write good code&quot;, but the more time I spend with the language the more I doubt how much of this is true. Good code is written by iterating on an idea and trying things out, and while the borrow checker can force more iterations, that does not mean that this is a desirable way to write code. I&#x27;ve often found that being unable to just move on for now and solve my problem and fix it later was what was truly hurting my ability to write good code.<p>The latter part of this is true for any strongly statically typed language (with Rust expanding this to lifetimes), which negates the beginning of this paragraph -- once you get things compiled, you won&#x27;t need to refactor, unless you are changing major parts of your interfaces. There are plenty of languages that do not have this problem because it is a design choice, hardly something Rust can &quot;fix&quot;, it&#x27;s what makes it Rust., Comment Author: lastgeniusua
Comment ID: 40173393, Comment Text: Allan Blomquist&#x27;s tooling demo they mention is incredible, go watch it:<p><a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=72y2EC5fkcE" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=72y2EC5fkcE</a><p>Really sells the value of having a tight developer feedback loop: it shows hot reloading for code and graphics, a reversible debugger, live profiling with flame graphs, a data inspector with data breakpoints, time travel inspection with a scrub bar, session sharing and replay with the same scrub bar and direct links from the call stack to a breakpoint, and more.<p>Above the many niggles they had with Rust itself, this greatly helps me understand why Rust left them wanting more from their working environment. They say they&#x27;ve switched back to Unity with <a href="https:&#x2F;&#x2F;hotreload.net&#x2F;" rel="nofollow">https:&#x2F;&#x2F;hotreload.net&#x2F;</a> to try to capture some of that, and now I see why. (It&#x27;s a shame that hot reloading tooling in Rust wasn&#x27;t ready for them yet, but I see why they&#x27;ve moved on instead of waiting&#x2F;contributing.), Comment Author: modernerd
Comment ID: 40173454, Comment Text: Interesting read! If I had not picked Elixir + Godot for the multiplayer game I&#x27;m making, then I would&#x27;ve gone with Rust for the whole thing. The old naive version of me would&#x27;ve tried doing it in C++ + Unreal but I knew better this time around.<p>I think multiplayer game devs are sleeping on Elixir! It has made the network side of things so much easier and intuitive with fast prototyping and built in monitoring - so many lifetime issues are easily found and addressed. I&#x27;m pairing Elixir with Godot, Godot is used for the frontend game client. And its crazy because I thought the game client part would be the &quot;hard&quot; part as it would be a new skillset to learn, but Godot makes the actual game part very easy. GDScript is easy to learn, and the way Godot uses &quot;signals&quot; is very similar to the backend code in Elixir with message passing so its not a huge cognitive shift to switch between server&#x2F;client code.<p>I get that BEAM doesn&#x27;t lend well to highly computational tasks, but I just don&#x27;t see how thats an issue for many types of multiplayer games? If you aren&#x27;t making some crazy simulation game, then most of the backend computation is more around managing client state and doing &quot;accounting&quot; every tick as inputs are processed. The most computational task I&#x27;ve had is server-side NPC Pathfinding, which I was able to quickly offload onto seperate processes that chug along at their own rhythm., Comment Author: mikhmha
Comment ID: 40173475, Comment Text: As a game developer for about two decades, I&#x27;ve never considered Rust to be a good programming language choice.<p>My priorities are reasonable performances and the fastest iteration time possible.<p>Gameplay code should be flexible, we have tons and tons of edge cases _by design_ because this is the best way to create interesting games.<p>Compilation time is very important, but also a flexible enough programming structure, moving things around and changing your mind about the most desirable approach several times a day is common during heavy development phases.<p>We almost never have specifications, almost nothing is set until the game is done.<p>It is a different story for game engines, renderers, physics, audio, asset loaders etc. those are much closer to system programming but this is also not where we usually spend the most time, as a professional you&#x27;re supposed to either use off-the-shelf engines or already made frameworks and libraries.<p>Also, ECS is, IMHO, a useful pattern for some systems, but it is a pain in the butt to use with gameplay or UI code., Comment Author: stephc_int13
Comment ID: 40173553, Comment Text: Now they need to try blockchain :), Comment Author: nottorp
Comment ID: 40173555, Comment Text: I&#x27;ve experienced a lot of these concerns while building <a href="https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;symbiants">https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;symbiants</a><p>I have a simple question that maybe someone smarter than me can answer confidently:<p>If I want to build something akin to Dwarf Fortress (in terms of simulation complexity) as a browser-first experience - what stack should I choose?<p>Originally, I prototyped something out using React, PixiJS, and ReactPixi (<a href="https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;antfarm">https:&#x2F;&#x2F;github.com&#x2F;MeoMix&#x2F;antfarm</a>). The two main issues I ran into were the performance of React&#x27;s reconciler processing tens of thousands of entities when most weren&#x27;t changing (despite heavy memoization) and GC lurching due to excess object allocations. My takeaway was that if I wanted to continue writing in JS&#x2F;TS that I would need to write non-idiomatic code to avoid excess allocations and abandon React. This approach would result in me effectively creating my own engine to manage state.<p>I decided to not go that direction. I chose Rust because no GC is a language feature (especially good since GCs in WASM are heavy) and I chose Bevy because it seemed like a fairly structured way to mutate a large amount of code.<p>Progress has been slow for a lot of the reasons listed in this article. I&#x27;ve written a lot of this off to WASM being a new frontier for game dev, and I&#x27;m new to Rust&#x2F;Bevy&#x2F;ECS&#x2F;gamedev, and rationalized my effort by noting there&#x27;s not a lot of complex simulation games running in browser (that I&#x27;m aware of).<p>It&#x27;s not clear to me that I&#x27;ve made the right decision, and just need to take the good with the bad, in order to develop the type of game I want in the type of environment I want., Comment Author: SeanAnderson
Comment ID: 40173567, Comment Text: Excellent article. Rust is my favorite language for several uses, but I&#x27;m becoming less optimistic about it as a versatile language long-term. An important point regarding the article is that it mixes rust shortfalls, and shortfalls of <i>any language other than C++</i> for games. I&#x27;ve personally used Bevy for a 3D wave function renderer, but moved away from it in favor of a custom WGPU-engine due to Bevy&#x27;s complicated ECS DSL.<p>I am worried because:<p><pre><code>  - Games seem like a no-go, as articulated in the article
  - Web usage has been dominated by Async, with no signs of reversing. I have no interest in this. And, there is no promising Django analog or ORM.
  - Emebedded support on Cortex-M, and to a lesser extend RISC-V is good at its core, but the supporting libraries have a mix of A: the game failures listed in the article (Driven by hype, mostly makers, serious companies are not using it), and B: Also being taken over by Async.
</code></pre>
This is disappointing to me, because IMO the syntax, tooling, and general language experience of Rust is far better than C and C++., Comment Author: the__alchemist
Comment ID: 40173585, Comment Text: As someone who&#x27;s become a core contributor to Bevy lately, while <i>also</i> doing contract work in Unity on the side, I obviously disagree with the idea that Rust isn&#x27;t up to the task of game dev. The grass isn&#x27;t greener on the Unity side, with a mountain of technical debt holding the engine back. (They&#x27;re still using Boehm GC in 2024!) Bevy is a breath of fresh air just because it&#x27;s relatively new and free of legacy. Using Rust instead of C++ is just one part of that. Bevy has a more modern design throughout: for instance, it has a relatively straightforward path to GPU-driven rendering in an integrated system, without having to deal with three incompatible render pipelines (BiRP, HDRP, URP).<p>What I find more interesting is the parts of the article that boil down to &quot;Rust isn&#x27;t the best language for rapid development and iteration speed&quot;. And that may well be true! I&#x27;ve long thought that the future of Bevy is an integrated Lua scripting layer [1]. You don&#x27;t even need to get into arguments about the suitability of the borrow checker: it&#x27;s clear that artists and designers aren&#x27;t going to be learning Rust anytime soon. I&#x27;d like to see a world in which Rust is there for the low-to-mid-level parts that need performance and reliability, and Lua is there for the high-level logic that needs fast iteration, and it&#x27;s all a nicely integrated whole.<p>Long-term, I think this world would actually put Bevy in a better place than the existing engines. Unity forces you into C# for basically everything, which is both too low-level for non-programmers to use and too high-level for performance-critical code (unless you have a source license, which no indie developer has). Unreal requires C++, which is even more difficult than Rust (IMO), or Blueprints, which as a visual programming language is way too high-level for anything but the simplest logic. Godot favors GDScript, which is idiosyncratic for questionable gain. I think Rust and Lua (or something similar) would put Bevy in a Goldilocks spot of having two languages that cover all the low-, mid-, and high-level needs well.<p>As for the other parts of the article, I disagree with the ECS criticism; ECS has some downsides, but the upsides outweigh the downsides in my view. I do agree that Bevy not having an official editor is an ongoing problem that desperately needs fixing. Personally, I would have prioritized the editor way higher earlier in Bevy&#x27;s development. There is space_editor [2] now, which is something.<p>[1]: <a href="https:&#x2F;&#x2F;github.com&#x2F;makspll&#x2F;bevy_mod_scripting">https:&#x2F;&#x2F;github.com&#x2F;makspll&#x2F;bevy_mod_scripting</a><p>[2]: <a href="https:&#x2F;&#x2F;github.com&#x2F;rewin123&#x2F;space_editor">https:&#x2F;&#x2F;github.com&#x2F;rewin123&#x2F;space_editor</a>, Comment Author: pcwalton
Comment ID: 40173670, Comment Text: Just waiting for someone to write a 5000 word essay on why they are moving from Rust to do data science stuff. Totally puzzled by everyone trying to get on to the Rust bandwagon on DS&#x2F;DE, when being able to iterate and make changes fast is why Python rules even though it is dog slow., Comment Author: npalli
Comment ID: 40173744, Comment Text: Tried Rust for a very simple game, it didn&#x27;t just feel right. It&#x27;s like the language itself is begging you not to use it for game dev. Lol, Comment Author: ArkimPhiri
Comment ID: 40173783, Comment Text: The TLDR I got from that: Normal coding has two concerns:<p>1. What behavior do I want?<p>2. How am I implementing that behavior?<p>Experimenting with #1 is slowed down by the current end point of #2. Sometimes not at all, sometimes a lot, depending on luck and how #2 anticipated the class of experiment I am trying.<p>Rust adds:<p>3. How can the implementation code be organized so its stringent safety checks are validated?<p>Now experimenting with #1 is complicated by two dimensions of design history instead of one. And the latter dimension being two steps of abstraction&#x2F;design-dependency away from concern #1, is going to be very brittle.<p>Never used Rust, but that sounds painful., Comment Author: Nevermark
Comment ID: 40173805, Comment Text: Clearly he needs a framework for making games in Rust instead of iterating through rust primitives., Comment Author: _obviously
Comment ID: 40173825, Comment Text: I&#x27;ve been writing Rust professionally (and predominantly) for ~5+ years now, with brief detours in game dev. I&#x27;ll defer to others who are <i>dedicated</i> game devs, but overall I think this article is well written and a healthy thing for Rust overall. We need this kind of breakdown if things are going to continue to improve.<p>I&#x27;d say I only have two somewhat arbitrary comments on this piece:<p><i>&gt; Rust on the other hand often feels like when you talk to a teenager about their preference about anything. What comes out are often very strong opinions and not a lot of nuance.</i><p>This is a rabbit hole of a topic so I don&#x27;t want to go <i>too</i> deep into it, but this isn&#x27;t a Rust-specific issue <i>(though it may be a current Rust issue)</i>. I&#x27;ve seen this same pattern play out across so many languages over the years, from Lisp to Rust to everything in between.<p>A very unscientific and definitely not charitable way I&#x27;ve thought about this over the years is that programming, by nature, is an OCD person&#x27;s dream. We wind up with a pretty large chunk of people who seemingly move language to language in the hype cycles in search of some weird nirvana level that is likely just unobtainable. I feel like Rust has slowly started shedding this as the community has grown&#x2F;matured and some people have moved on to the next hype cycle but I often find myself wishing it&#x27;d happen faster.<p>I write Rust because when I sleep at night, I just don&#x27;t get woken up by being paged for nearly as many weird edge cases. The Rust I write often has a litany of compromises because I want to just get shit done and move on with my life, and the remaining guarantees are still good enough. The number of times I&#x27;ve had to tell people to leave it be is definitely higher than it should be.<p><i>&gt; I know that just by saying &quot;global state&quot; I&#x27;m immediately triggering many people who have strong opinions on this being wrong. I feel this is one of those things where the Rust community has created a really harmful and unpractical rules to put on projects&#x2F;people.</i><p>This isn&#x27;t really a Rust-specific thing, though I can&#x27;t fault the author for including it. People have been beating the drum of &quot;no globals&quot; for as long as I can remember... and simultaneously, as long as I can remember, game devs have come out of the woodwork to politely explain that the programming they do is often under very different constraints.<p>I still periodically use global state for things because it&#x27;s just faster at points, and no, I&#x27;ve never cared if people get annoyed by it.<p>Anyway, here&#x27;s to hoping this leads to positives for the community., Comment Author: Klonoar
Comment ID: 40173837, Comment Text: I&#x27;ve worked on Ambient Engine and now on the Bevy engine. I totally agree with these points, very valuable.<p>I only make some comments from my professional (audio) perspective:<p>We need the highlight author&#x27;s affirmation of cli. Rust&#x27;s tui (ratatui) is great. I used it to make Glicol-cli [1]. If you are a Linux user, you are welcome to test the music production of the code.<p>Speaking of game audio, I actually think rust is perfect for audio. I have also continued to develop Glicol [2] recently, and my recent goal (starting tomorrow) is the bevy_glicol plug-in. I want to solve bevy&#x27;s audio problem on the browser.<p>All in all, even though I&#x27;ve had my share of pain with ecs, I still think rust is very valuable for game and app development, maybe not multiplayer AAA, maybe practical apps.<p>[1] <a href="https:&#x2F;&#x2F;github.com&#x2F;glicol&#x2F;glicol-cli">https:&#x2F;&#x2F;github.com&#x2F;glicol&#x2F;glicol-cli</a><p>[2] <a href="https:&#x2F;&#x2F;github.com&#x2F;chaosprint&#x2F;glicol">https:&#x2F;&#x2F;github.com&#x2F;chaosprint&#x2F;glicol</a>, Comment Author: chaosprint
Comment ID: 40173892, Comment Text: I use Nim at work. It is a joy. I replaced a prototype Rust application which was confirmedly <i>not</i> a joy. None of Rust&#x27;s highly opinionated safety semantics necessarily imply a better end product, and often make delivering an end product much more difficult. Rust has use cases, but it is a specialized hammer for a specific domain of nails. It is not the cure-all everyone wants it to be.<p>If you&#x27;re asking if you should use Rust and you don&#x27;t have a highly specific embedded use case, you should probably just use a language with decent RC or GC. As an additional bonus, 99.9% of the code you write in a GC language never has to be about memory <i>at all</i>. Business logic, clean and bare., Comment Author: netbioserror
Comment ID: 40173895, Comment Text: &gt; Secondly, procedural macros are incredibly difficult to write, and most people end up using very heavy helper crates<p>lisp lisp lisp lisp lisp lisp lisp lisp, Comment Author: dj_mc_merlin
Comment ID: 40173917, Comment Text: My experience is that the ecosystem is a mess, have hit winit, wgpu, and countless bevy bugs, iteration times are abysmal, documentation is nonexistent. In the time it would take me to make a game in popular Rust tooling I could build the game and engine from scratch in C and also have something that would crash less., Comment Author: cshenton
Comment ID: 40173921, Comment Text: &gt; wait I can&#x27;t add this new thing because things will no longer compile, and there&#x27;s no workaround other than code restructuring<p>I definitely think that&#x27;s a great feature. I want to learn on day 2 that the design is a dead end, not on day 101 when I ship on day 100 and there was a race condition on day 2 I never noticed.<p>But the thing about gamedev (I guess - I&#x27;m not a game developer) is that the code being great and doing what you <i>hope</i> it will do isn&#x27;t 100% of the job as it is in other disciplines. In gamedev you may want to <i>run</i> the code, and the way it runs (fun, feel, whatever) might be bad even though it compiles, works according to a spec and so on. So while I&#x27;m usually happy to write code for a week and never run it - game development feels like it&#x27;s all about the iteration.<p>That said, game development is also game <i>engine</i> development. And Rust seems absolutely perfect for engine development (you need &quot;fearless&quot; concurrency and performance and there are zero mainstream languages that will do that other than rust). For people who feel it&#x27;s too rigid or hard to iterate with perhaps hybrid could work. Like Rust + Lua or something sounds like it could be worth trying., Comment Author: alkonaut
Comment ID: 40173937, Comment Text: Oh my, this has to be my favorite quote in a blog in a long long time.<p>&quot;... many if not most of the problems don&#x27;t go away if one isn&#x27;t willing to constantly refactor their code and treat programming as a puzzle solving process, rather than just a tool to get things done.&quot;<p>I have thought it was just me for a long time, but many of the popular styles of programming that we push definitely seem to require constant refactors in the pursuit of a solution.  And I definitely see more tire spinning for the sake of the build than I do for whatever it was folks were building.<p>Great quote., Comment Author: taeric
Comment ID: 40174136, Comment Text: &gt; because the thing you might need to do is not available in the place where you&#x27;re doing the thing<p>I noticed this with Rust. That sometimes Rust forces you to pull some things up the call stack in order to access them. Even if the semantics of what you do is the same Rust doesn&#x27;t let you have things in arbitrary places.<p>It&#x27;s super weird and possibly annoying when you hit it for the first time but if you stop and think about it, the place where Rust forces you to put it is a really good place from architectural standpoint.<p>It basically prevents you from taking parts of a thing and delegating responsibility for them to some children, which seems restrictive, but it provides you with consistent structure of where to look for things that are responsible for something.<p>Rust is restrictive in so many subtle ways (and some obvious ones) but I haven&#x27;t seen one where it leads to worse outcomes. Maybe I have too little experience., Comment Author: scotty79
Comment ID: 40174289, Comment Text: Great article, but on ECS I thought the primary point of using it was locality of memory so that you don&#x27;t get cache misses during iteration of elements. Yes you are preferring composition over inheritance but I thought that was more of a side-benefit to the main thing ECS was trying to solve., Comment Author: Sleaker
Comment ID: 40174355, Comment Text: Wonder if Mojo will become a good option as it matures, Comment Author: qaq
Comment ID: 40174550, Comment Text: I only skimmed this article, but, despite it being very negative about Rust, I almost 100% <i>agree with it</i>: Rust is a HORRIBLE choice for game dev. I might quibble with how they outline the costs and benefits of some of the design patterns that rust forces you into, for instance I think command lists are actually incredibly useful and perfectly fine as a game development thing and not the huge problem they consider them to be, and generational arenas basically solve any pointer ownership problems in game development in my opinion, but they are right in the main.<p>I know, because I&#x27;ve tried it. Once. I would #never* recommend Rust to game developers, especially not indie ones. In fact I&#x27;d recommend against it strenuously!<p>And this is precisely because Rust is explicitly and knowingly focused on correctness, safety, perfectly clean code, etc at the cost of iteration speed and flexibility and dynamicism, and that&#x27;s bad for designing game mechanics and even just <i>getting a game done</i> — games have an inherently short life span and development cycle, so safety and correctness and code quality don&#x27;t matter a whole lot. It&#x27;s okay if they crash, etc, as long as they work enough to play. It&#x27;s okay if the code is ugly, you probably won&#x27;t be working on it for very long. This is even moreso the case, as the author says, because in writing a game you really want to be able to iterate quickly and just. Do shit as an experiment, even if it&#x27;s temporary, to see how it feels.<p>On the other hand, who I <i>would</i> recommend Rust to is the people writing game <i>engines</i>, where you really will probably be working on that code for years to come, where stability and correctness is pretty important, and so where Rust&#x27;s strengths will really shine — but crucially, even then, I&#x27;d tell them to make it a real engine, not a game framework like Bevy, by adding a highly flexible, dynamic scripting language like Lua or even C#, and a data format for specifying scenes and entities, and an editor. That way you don&#x27;t write your game in Rust at all!, Comment Author: logicprog
Comment ID: 40174554, Comment Text: I&#x27;ve been working in gamedev since 2007 and toyed with Rust since 2014. I simply don&#x27;t think that majority of games, especially indie games, have performance requirements high enough to justify using anything other than a high-level, garbage collected language.<p>Of course, some titles like Factorio are outliers. But for majority of games time you would spend to work with manual memory management in C or borrow checker in Rust would better be spent on other things., Comment Author: golergka
Comment ID: 40174637, Comment Text: I&#x27;ve found Rust very pleasant for building little games. I&#x27;ve mostly been using SDL + a my own little shim so I can target web through wasm &amp; canvas.<p>I had professionally worked with C++ for a long time so getting comfortable with Rust wasn&#x27;t too bad.<p><a href="https:&#x2F;&#x2F;www.bittwiddlegames.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;www.bittwiddlegames.com&#x2F;</a>
You can see a web build at 
<a href="https:&#x2F;&#x2F;www.bittwiddlegames.com&#x2F;lambda-spellcrafting-academy&#x2F;demo" rel="nofollow">https:&#x2F;&#x2F;www.bittwiddlegames.com&#x2F;lambda-spellcrafting-academy...</a>, Comment Author: bittwiddle
Comment ID: 40174657, Comment Text: I think these comments are fair. It&#x27;s true that Rust is <i>rigid</i>.<p>I&#x27;ve had great success with Rust, but on projects where I knew exactly what I needed to build. Rust&#x27;s focus on code correctness is great for maintenance of projects, where the priority is in keeping them stable and not causing regressions.<p>So while I&#x27;d say Rust is pretty quick for refactoring of something like a device driver, it&#x27;s far away from the hot-reloaded time traveling live tinkering IDE., Comment Author: pornel
Comment ID: 40174903, Comment Text: My favorite thing about rust is when rust devs say that the slow compile things aren&#x27;t a big deal and then show how that just by dropping a few dependencies you can get hello world down from 90 seconds to 30 seconds., Comment Author: thefaux
Comment ID: 40175032, Comment Text: Rust is a terrible language for everything except a few niche tools., Comment Author: 0xfedbee
Comment ID: 40175067, Comment Text: I&#x27;ve been leaning into Rust almost purely to escape from the mess that is C&#x2F;C++ tooling which always makes considering a new dependency a time sink.<p>Can someone explain the obsession with combining ECS with generational arenas?, Comment Author: james4k
Comment ID: 40175116, Comment Text: You can feel the paranoia of the author stating 20000 times it&#x27;s his opinion, giving context, etc just cause he knows the langstans reaction., Comment Author: epolanski
Comment ID: 40175159, Comment Text: I respectfully disagree with the author&#x27;s title choice.<p>My first impression is, of course, that the issue is there is no production Game or GUI framework around.<p>The author seems to complain mainly about the choices of frameworks and how bad or opinionated they are. I agree. Even Egui is too opinionated, but it makes sense on some level.<p>It is no problem to use bindings to some software written in C++. Rust was created to solve this exact problem: rewrite big projects that were written in C++, by slow mutation in Rust.<p>Honestly, I would add further that until the Unreal Engine uses Rust, we should not expect widespread Rust adoption. It will likely start with a company creating its own really custom game engine, the game becoming a bestseller, and it will spread iteratively over the years from there.
Or maybe there will be a better option beyond Rust at that point.<p>This is the status quo: <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;shorts&#x2F;_zwKHgtQpc8" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;shorts&#x2F;_zwKHgtQpc8</a>
Let us be realistic.<p>Beyond that: One should see Rust as writing C with someone watching over you to remind you that you need to know the writer for each memory value. It picks up work off you. Or it should. If it doesn&#x27;t, yes that is a problem, and we&#x2F;you are doing it wrong.<p>But yes, if you are doing something that the borrow checker complains about, in other languages, either that semantic difference would have been hidden, or you would be paying for it later.<p>There, the author makes a point that he wants the code to work now. That is possible, and you can hotwire bad code in Rust, too. But I am sure that code is why we end up with games like Jedi Survivor.<p>There is no fundamental inability of Rust to do the things the author demands.
If you want dynamic loading, use <a href="https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;libloading" rel="nofollow">https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;libloading</a> (And you don&#x27;t need to use the library).
Do you want a global state? I will disagree with you, but take a look at, e.g., how the Dioxus project is doing it. Again I think that is always a terrible mistake, and people are thinking really of using an arena or a registry really., Comment Author: eftychis
Comment ID: 40175182, Comment Text: Rust is not a practical language and fails at many of the things that were part of its original vision.<p>The main point of Rust is to have an excuse to rewrite things from scratch unhindered by legacy, but that won&#x27;t particularly improve their quality.<p>I suppose you could also make some friends as part of joining the cult., Comment Author: mgaunard
Comment ID: 40175327, Comment Text: I decided that Rust wasn&#x27;t for me after a week long side project. But I doubted myself for a long time, as Rust seemed like such a great idea for so many reasons and it seemed like a bunch of other people were using it successfully. So I&#x27;m glad to see this article and know that it wasn&#x27;t just me., Comment Author: modeless
Comment ID: 40175427, Comment Text: This is a decent article, but although the points themselves are valid, I think there&#x27;s a core &quot;issue&quot; with (indie) gamedev itself.<p>The vibe that I&#x27;m getting is that it&#x27;s filled with people that don&#x27;t particularly care about programming, they just want to get stuff done(TM), this is also highlighted by the fact that they are willing to write completely inadequate code just to see things working. Rust is not that, and that&#x27;s a good thing.<p>More generally, I&#x27;d say that in gamedev anything goes, as long as it&#x27;s fun and isn&#x27;t <i>too</i> buggy. Rust is not, and never will be able to accomodate that mindset, which again, is a good thing if you think for 2 seconds and consider what Rust is actually aimed at, which is safe systems programming.<p>You <i>can</i> have the core engine written in Rust and have a scriptable language on top of it, there aren&#x27;t any major pain points in this regard. The scriptable language will be able to provide all of this hot-reloading-anything-goes-yes-sir bullshit that we all know and love.<p>tl;dr: Use the right tool for the job. A language designed for safe systems programming can&#x27;t do non-safe non-systems programming very well. Who knew!<p>Virtually all of the points outlined in the article stem from the above., Comment Author: qweqwe14
Comment ID: 40175518, Comment Text: I also had the same bad experience with Rust outside of Gamedev. Probably a lot of other people too, but people don&#x27;t talk about it much, because the Rust community is the most religious programming language community I&#x27;ve ever seen in my life. Before Rust, the Scala community was also pretty bizarre (Java too for a while), but nothing was on Rust&#x27;s level. The worst part about Rust isn&#x27;t technical, it&#x27;s the crazy community. You can see in the article that the author tries to explain everything at every point, trying to escape the problem &quot;If you don&#x27;t understand something in Rust, you&#x27;re holding Rust wrong.&quot;<p>Of course, there are many people in the Rust community who are not religious and try to improve the language, but my general feeling after reading a lot about Rust is to stay very far from the church of Rust.<p>The best response to this type of community is humor, like this video about a Rust Senior developer <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=TGfQu0bQTKc" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=TGfQu0bQTKc</a>, Comment Author: zac23or
Comment ID: 40175625, Comment Text: Jesus, now that&#x27;s what I call comprehensive.<p>On the &quot;hot reloading&quot; remark: I believe that, to some extent, compiled languages that lean into metaprogramming are innately at odds with the concept of hot reloading. You&#x27;re spitting out a (mostly) monolithic binary - rewriting that on the fly just isn&#x27;t going to be reliable beyond an extremely basic level, and shoving it all into some kind of VM for the purposes of hot reloading introduces variance and general performance overhead that both mean that the &quot;hot reload&quot; environment is no longer an accurate depiction of the real application&#x27;s behavior., Comment Author: ryukoposting
Comment ID: 40175744, Comment Text: I&#x27;d be interested to hear the author&#x27;s take on Nim [1], which seems to be better suited for game development than Rust by staying out of the dev&#x27;s way [2], and supports hot-reloading (at least in Unreal Engine 5) [3]?<p>[1] <a href="https:&#x2F;&#x2F;nim-lang.org&#x2F;" rel="nofollow">https:&#x2F;&#x2F;nim-lang.org&#x2F;</a><p>[2] <a href="https:&#x2F;&#x2F;youtu.be&#x2F;d2VRuZo2pdA?si=E3N62oUJ-clXozCg" rel="nofollow">https:&#x2F;&#x2F;youtu.be&#x2F;d2VRuZo2pdA?si=E3N62oUJ-clXozCg</a><p>[3] <a href="https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Cdr4-cOsAWA" rel="nofollow">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Cdr4-cOsAWA</a>, Comment Author: misswaterfairy
Comment ID: 40175881, Comment Text: You might not need memory safety., Comment Author: andrewstuart
Comment ID: 40175902, Comment Text: C minus minus is needed to strip away as much as possible from C++, Comment Author: andrewstuart
Comment ID: 40175919, Comment Text: I wonder if Rust is just much better suited for making <i>game engines</i> than it is for making games.<p>The relative abundance of game engines made in Rust compared to actual games is a bit of a meme, but I think there&#x27;s something to it. Maybe Rust&#x27;s feature set is just not the best fit for gamedev, for reasons outlined in TFA. Maybe it means that game engines built in Rust (which I do feel Rust is well suited for) should try to integrate an interpreter for some higher level language, IDK., Comment Author: harpiaharpyja
Comment ID: 40176186, Comment Text: This is a fantastic article. Thorough, nuanced, well-articulated, and rooted in lots of real experience, Comment Author: brundolf
Comment ID: 40176287, Comment Text: Yup. Rust is too complicated. You don&#x27;t think about getting the job done, you think about language specific crap that is just overhead. And it&#x27;s ugly to look at.<p>I tried to like it, but I can&#x27;t. It doesn&#x27;t align with my way of thinking., Comment Author: lakomen
Comment ID: 40176713, Comment Text: hah Rust didn&#x27;t get gamedev (success at all costs) and it&#x27;s a disaster, Comment Author: whateveracct
Comment ID: 40176719, Comment Text: When I set out to learn Rust about a decade ago, I chose to write a game - a clone of &quot;Empire&quot; that I call Umpire.<p>It&#x27;s a different task to re-implement an already-designed language rather than designing and implementing at the same time. Nevertheless I have run into a number of the difficulties mentioned in the article, and arrived at my own solutions - foremost passing around global UUIDs rather than actual `&amp;` references, and enforcing existence constraints at runtime.<p>I&#x27;ve experienced the protracted pain of major refactors when assumptions baked into my data model proved false.<p>In some regards these refactors wore some of the shine off of Rust for me as well. BUT I&#x27;m still glad the game is implemented in Rust, exactly because of Rust&#x27;s dual emphasis on safety and performance.<p>The AI I&#x27;m developing requires generation of massive quantities of self-play data. That the engine is as fast as it is helps greatly.<p>Rust&#x27;s strength in ML means my AI training and game code can share important types, ensuring consistency.<p>The effectiveness of Rust for writing CLI tools (mentioned in the article) has lent itself to a number of game-specific command-line interfaces that are of high quality.<p>Rust&#x27;s memory safety became critical once I decided to network the game. I don&#x27;t want `umpired` to be any more exploitable than it needs to be.<p>My constraints have been very different than the OP&#x27;s; obviously it makes sense for their studio given their experience to move away from Rust. But I think Rust still has a place in games.<p>* <a href="https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Empire:_Wargame_of_the_Century" rel="nofollow">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Empire:_Wargame_of_the_Century</a>
* <a href="https:&#x2F;&#x2F;github.com&#x2F;joshhansen&#x2F;Umpire">https:&#x2F;&#x2F;github.com&#x2F;joshhansen&#x2F;Umpire</a>, Comment Author: pc2g4d
Comment ID: 40176964, Comment Text: [dead], Comment Author: devilsAdv0cate
Comment ID: 40177101, Comment Text: Very interesting article but I feel the need to question some things.<p>- The very first thing that comes to mind is <i>why</i> actually use Rust for gamedev. From the article it seems like the author got into Rust through Godot, but that does not explain why commit to use Rust for a full game. What was the reasoning behind picking Rust?<p>- It feels to me that there&#x27;s a mix of criticism to Rust as a language, Rust as a community and libraries&#x2F;frameworks written in Rust (in particular Bevy). Personally I think these are completely separated matters so I would like to know why the author treats them all as a unit.<p>- I&#x27;ve always got the impression that gamedevs try to have their cake and eat it too which is almost always impossible: they want to have quick iterations and write &quot;simple code&quot; while having low level control of everything (ex. manual memory management, usage of pointers, etc.). For example, the author mentions wanting access to methods like &quot;play_sound()&quot; but at the same time mentions that some patterns are unacceptable given the &quot;overhead [...] due to memory locality&quot;. I&#x27;ve never heard of an ecosystem where you can have everything without any compromises.<p>- In particular, I get the impression that the author has a lot of troubles with ECS and instead it tries to bend it to work in a OOP fashion (for example, through the usage of &quot;fat components&quot; as he calls them or preferring virtual dispatch over `match` statements). He claims that he has put in a &quot;lot of time&quot; in trying to make it work but I get the impression that this effort was mostly wasted in trying to bend the language and libraries into something that just won&#x27;t work out. It&#x27;s like trying to use a circular saw to polish mechanical watch pieces: an exercise in frustration. At some point in time I&#x27;m sure he asked himself why to keep on pushing on, and I would like to know why he continued to be committed to such process.<p>- The author claims multiple times that they work in a single threaded environment where they should not care about concurrent access so they should not pay the price in the type system. I agree that this should be the case but then it proceeds to list examples that show a different situation. One of them is the claim that they cannot use a &quot;god&quot; context to pass down every dependency due to the borrow checker, listing code that tries to hold a reference to a &quot;camera&quot; system while passing the context to the &quot;player&quot; system. In particular this does not make sense because: 1) If you&#x27;re in a single threaded environment you don&#x27;t have two systems using the same context at the same time (because there is no &quot;at the same time&quot;); 2) if the &quot;player&quot; system does not need the camera then it won&#x27;t change it, and if it does not change it then there is no need to take a reference to it earlier, you can just take it after the &quot;player&quot; system has finished. I know that coming up with brief examples is extremely difficult but either the example does not properly represent the reality, or the author is actually working in a multi threaded environment (maybe without actually knowing about it).<p>As an observation, the author mentions multiple times that Rust pushes you to write &quot;good code&quot; and I fundamentally disagree. &quot;Good code&quot; is very contextual, just like the idea of &quot;simple code&quot; where he checks for all collisions and plays a sound in 3 lines (is this actually &quot;simple&quot;?), so instead I would say that Rust forces you to write &quot;correct code&quot;, that is, code that won&#x27;t (or is unlikely to) fail at runtime. I believe this is a very important distinction that you always need to keep in mind when evaluating a tool such as a programming language.<p>Finally, I do believe though that Rust is a bad choice if what you&#x27;re interested in is to build games quickly without consideration for performance (and you most likely don&#x27;t need to care in 2d games) and their decision is very reasonable: C# and Unity are just aligned better with what the author is actually interested in doing., Comment Author: valcron1000
Comment ID: 40177342, Comment Text: Rust is good for software following a strict spec and design doc. A lot of what I do is exploratory in nature. Rust sucks there, fighting me. Best kind of languages in those cases are Lisp, Python and (unironically) C with Visual Studio debugger., Comment Author: z3phyr
Comment ID: 40177534, Comment Text: I think there&#x27;s a certain type of mind that can truly appreciate Rust as a language and enjoy developing with it. When I see quotes like,<p>&gt; I wasn&#x27;t thinking &quot;what&#x27;s the right way to get a random generator in here&quot; or &quot;can I assume this being single threaded&quot; or &quot;am I in a nested query and what if my archetypes overlap&quot;, and I also didn&#x27;t get a compiler error afterwards, and I also didn&#x27;t get a runtime borrow checker crash. I used a dumb language in a dumb engine and just thought about the game the whole time I was writing the code.<p>and,<p>&gt; The prevalence of perfectionism and obsession with &quot;the correct way&quot; in the Rust ecosystem often makes me feel that the language attracts people who are newer to programming, and are easily impressionable.<p>I see someone who simply does not think about those kinds of things when writing code. And that&#x27;s completely, entirely fair. Rust is not for them, then.<p>But they seem to act like it&#x27;s an issue with the language that it does not serve them specifically, and their way of thinking in particular, not even pertaining to game development.<p>Because the thing is, I don&#x27;t suffer from the issue they&#x27;re describing. I don&#x27;t find it difficult or distracting to think of edge cases and implementation details when I am writing out a solution. In fact, I can&#x27;t help it. I love Rust, because its strong typing and strict static analysis actually support and justify my way of thinking. They&#x27;re not obstacles for me to overcome, certainly not like how it&#x27;s described here.<p>When I use a language like JavaScript, people tell me that I care too much about details or that I don&#x27;t need static type information because I can just assume. JavaScript is not for me, because it doesn&#x27;t support my way of thinking. It is terrible and sloppy and completely unchecked. It&#x27;s absolutely great for banging things out without giving a care in the world about a single implementation detail that isn&#x27;t relevant to the actual problem at hand. It&#x27;s terrible if you actually do care about those implementation details, because nobody else who writes JavaScript does. Everything you interact with is going to be just as shoddy as the language itself.<p>(I have a job writing JavaScript, so this doesn&#x27;t mean that I can&#x27;t use the language. It just means I do not like it. I do like TypeScript.)<p>So this might just be a fit issue. I haven&#x27;t read the rest of the article yet, because this stuck out to me. I see some other HN comments talking about async code and GUI libraries, and those are all completely valid concerns, but in the article these valid shortcomings are seemingly mixed with what I&#x27;m going to call &quot;neurotype issues&quot;. In other words, I suppose the author just isn&#x27;t autistic enough. It has nothing to do with being new to programming or not.<p>And that&#x27;s fine. It&#x27;s just not an issue with the language that it doesn&#x27;t serve you as well as it serves others. After all, Haskell is the same way. I&#x27;d say most programming languages are the same way., Comment Author: LoganDark
Comment ID: 40177542, Comment Text: <i>Other languages allow much easier workarounds for immediate problems without necessarily sacrificing code quality.</i><p>I really wish the author had followed this with a list and an explanation., Comment Author: solidsnack9000
Comment ID: 40177563, Comment Text: I don&#x27;t use Rust for game dev but I do for low level libraries and find it easier than C++ to get started. I have enjoyed it more than Java and like it for different reasons than Go, but it feels good to program in.<p>As for the design patterns that a complex game requires, if you are considering Rust for game dev and ecs design patterns it might be useful to check out projects that are Rust centric like <a href="https:&#x2F;&#x2F;spacetimedb.com&#x2F;" rel="nofollow">https:&#x2F;&#x2F;spacetimedb.com&#x2F;</a>., Comment Author: hendler
Comment ID: 40177643, Comment Text: Can you not curate an opinionated subset of C that enforces all of Rust&#x27;s rules so that you can have a safe variant of C, just by removing flexibility and enforcing some programming patterns?, Comment Author: blindriver
Comment ID: 40177656, Comment Text: &gt; being unable to just move on for now and solve my problem and fix it later<p>Same thing about Golang &quot;unused variable&quot; and &quot;unused import&quot;. So many times I just exploring a lib and trying things out with no intention to leave it as is, but no, Go forces to &quot;write good code&quot;., Comment Author: deepsun
Comment ID: 40177838, Comment Text: This author is done more serious Rust code than I have, but I wonder: why not just abuse `clone`, `unwrap`, `Arc`, or even `transmute`?<p>Rust does try to force you to refactor sometimes, but you have the option to fight back., Comment Author: resonious
Comment ID: 40177848, Comment Text: Well, I needed something to do while I wait for the next Vampire Survivors addon. Purchased the full bundle. Good luck, game devs., Comment Author: robertlagrant
Comment ID: 40177867, Comment Text: &gt; ECS in Rust has this tendency of turning from something that is considered a tool in other language to become almost a religious belief.<p>I think bevy ui is the best example to give, it&#x27;s like nobody ever did a ui framework with a pure ECS before. You can conclude either that&#x27;s because it makes no sense to do that or that&#x27;s because nobody has ever came up with the right way to do that. The bevy community thinks it&#x27;s the latter.<p>It&#x27;s especially concerning because they constantly talk about the editor, even though they don&#x27;t even have any of the fundamental pieces for a gui framework in place. In bevy ui there is no way to create a reusable ui component, there are ways to do it but they all suck. So it&#x27;s not even a matter of a lack of widgets or something, the problem is you can&#x27;t even write a reusable widget, there is no foundation for a ui framework, and there isn&#x27;t even a real plan to change it because nobody knows how to write a gui framework with a pure ECS.<p>But even if they figured that out, things like text input fields can&#x27;t be properly implemented because there is no proper text rendering engine in bevy so they have to rewrite that first. Except that all rust text render&#x2F;layout solutions in rust (it has to be pure rust because wasm&#x2F;because it&#x27;s rust) are still very experimental and immature.<p>It&#x27;s a huge pain in the ass, people write games in rust because they want to write rust, not because they want to write games., Comment Author: lyu07282
Comment ID: 40177877, Comment Text: I tried to get Jonathan Blow engaged in the Rust RFC process to improve productivity for gamedevs. However, he thought it was a better idea to start working on his own language (Jai).<p>When I did some research for the Piston project, I learned that there was a productivity technique called &quot;meta parsing&quot; which was used in late 60s to develop the first modern computer. This was before C. The language was Tree-Meta. Viewpoint Research Institute upgraded it to OMeta.<p>I thought OMeta was too complex, so I developed Piston-Meta, an alternative for Rust using a simple data structure: Start node, end node, text, bool and f64., Comment Author: bvssvni
Comment ID: 40178042, Comment Text: Congrats on the game launch. Funny way to promote it. Good luck, hope you get some sales!, Comment Author: wly_cdgr
Comment ID: 40178081, Comment Text: There are vanishingly few reasons why anyone wouldn&#x27;t use a garbage collected language in modern software. I think a lot of the people using rust haven&#x27;t realised how much this limits its utility. As a result of this, the language has been presented as much more widely applicable than it actually is., Comment Author: James_K
Comment ID: 40178180, Comment Text: I think the crux is this heading: <i>Making a fun &amp; interesting games is about rapid prototyping and iteration, Rust&#x27;s values are everything but that</i><p>Jon Blow said that in one of his talks:  Rust treats all code as production code. For most of the duration of a project, that&#x27;s counterproductive, because it introduces a significant amount of unnecessary friction.<p>For most of a game&#x27;s development, you&#x27;re trying to figure out what the game&#x27;s supposed to be. Only later does it crystallize. Rust doesn&#x27;t recognize the non-crystalline phase, or rather explicitly rejects it as invalid., Comment Author: andai
Comment ID: 40178854, Comment Text: Really well written, and well explained without any bait, Comment Author: hyperbrainer
Comment ID: 40179052, Comment Text: I&#x27;ve always been fascinated by games and I&#x27;ve always loved programming but except for the beginning I&#x27;ve never combined the two. And the issue with game dev and functional languages not seeming to jive with each other always seemed (from the outside) to mostly be one of established norms conflicting with each other on both sides. I&#x27;d love to have time to explore this; for example one complaint the author makes is about passing around the game state but then also needing to pass around sub-parts of it and Rust complaining; this would be trivial or a non-problem in Elixir, but I know that&#x27;s because there&#x27;s no mutable state and in Rust&#x27;s case it must deal with mutable state regions because all of game dev assumes that&#x27;s available (or it must be by necessity for performance reasons)., Comment Author: pmarreck
Comment ID: 40179085, Comment Text: That&#x27;s Rust for you - as much language-level derangement as people hated about 90s Java, but without the memory safety benefits of Java., Comment Author: juped
Comment ID: 40179091, Comment Text: This article hits every note of frustration I&#x27;ve gotten with rust.<p>It honestly feels that if you want a somewhat memory safe language for more general purpose use cases good&#x27;ol fashion Ada or maybe ziggs (or if carbon ever become a thing) seem 100% more approachable than rust for gamedev or gui.<p>The only way I see rust becoming dominant in gamedev&#x2F;ui is by sheer brute force., Comment Author: 0dayz
Comment ID: 40179117, Comment Text: Seems like a few contradictory ideas here.<p>Rust is supposed to be a better safer C&#x2F;C++.<p>Then lot of comments here that games are best done in C++.<p>So why can&#x27;t Rust be used for games?<p>What is really missing beyond an improved ecosystem of tools. All also built on Rust., Comment Author: FrustratedMonky
Comment ID: 40179369, Comment Text: This is a fantastic article.<p>Personally, I found using Godot with some parts in Rust via gdext quite enjoyable.<p>You can avoid dealing with GDScript for important parts of the code and have access to OS threads if you want them, etc. - but can also prototype features in GDScript and write the UI, etc. there for fast testing, and keep a good separation of UI and graphics presentation vs. the actual game logic., Comment Author: GardenLetter27
Comment ID: 40180035, Comment Text: I&#x27;m amazed that we still willingly put heavy compute into compile steps<p>The trade off is always reload ability<p>We have CI, we have LSP places we can put heavy checks without sacrificing our ability to hot reload fast<p>In some checkers you can put in your own custom checks too, Comment Author: slifin
Comment ID: 40180847, Comment Text: the hype is starting to come down, Comment Author: jokoon

Authors and their story counts:
Author: thunderbong, Story Count: 3
Author: PaulHoule, Story Count: 3
Author: vyrotek, Story Count: 2
Author: tosh, Story Count: 2
Author: todsacerdoti, Story Count: 2
Author: rntn, Story Count: 2
Author: kryster, Story Count: 2
Author: fanf2, Story Count: 2
Author: bookofjoe, Story Count: 2
Author: zdw, Story Count: 1
Author: zaikunzhang, Story Count: 1
Author: yawpitch, Story Count: 1
Author: xkriva11, Story Count: 1
Author: whereistimbo, Story Count: 1
Author: wglb, Story Count: 1
Author: vmatsiiako, Story Count: 1
Author: url, Story Count: 1
Author: throwup238, Story Count: 1
Author: theoldlove, Story Count: 1
Author: teleforce, Story Count: 1
Author: taylorbuley, Story Count: 1
Author: taubek, Story Count: 1
Author: swores, Story Count: 1
Author: swiftcoder, Story Count: 1
Author: surprisetalk, Story Count: 1
Author: spathak, Story Count: 1
Author: skilled, Story Count: 1
Author: sizzle, Story Count: 1
Author: satvikpendem, Story Count: 1
Author: saturn5k, Story Count: 1
Author: sahin, Story Count: 1
Author: rustoo, Story Count: 1
Author: rmason, Story Count: 1
Author: redbell, Story Count: 1
Author: rbanffy, Story Count: 1
Author: perihelions, Story Count: 1
Author: panabee, Story Count: 1
Author: onnnon, Story Count: 1
Author: ohjeez, Story Count: 1
Author: nsoonhui, Story Count: 1
Author: nobody9999, Story Count: 1
Author: neel8986, Story Count: 1
Author: nateb2022, Story Count: 1
Author: myaccountonhn, Story Count: 1
Author: mxmzb, Story Count: 1
Author: mpweiher, Story Count: 1
Author: mpmisko, Story Count: 1
Author: montgomery_r, Story Count: 1
Author: mikhael, Story Count: 1
Author: martingalex2, Story Count: 1
Author: makerdiety, Story Count: 1
Author: luu, Story Count: 1
Author: ludovicianul, Story Count: 1
Author: lightlyused, Story Count: 1
Author: lermontov, Story Count: 1
Author: latexr, Story Count: 1
Author: json_bourne_, Story Count: 1
Author: jmcphers, Story Count: 1
Author: jger15, Story Count: 1
Author: jackflintermann, Story Count: 1
Author: ipython, Story Count: 1
Author: ingve, Story Count: 1
Author: herbertl, Story Count: 1
Author: henrik_w, Story Count: 1
Author: guluarte, Story Count: 1
Author: gmays, Story Count: 1
Author: gitinit, Story Count: 1
Author: fgblanch, Story Count: 1
Author: exolymph, Story Count: 1
Author: epilys, Story Count: 1
Author: elorant, Story Count: 1
Author: drdee, Story Count: 1
Author: dp-hackernews, Story Count: 1
Author: dcgoss, Story Count: 1
Author: davikr, Story Count: 1
Author: darthdeus, Story Count: 1
Author: dargscisyhp, Story Count: 1
Author: dangoldin, Story Count: 1
Author: cubemaster, Story Count: 1
Author: commons-tragedy, Story Count: 1
Author: coloneltcb, Story Count: 1
Author: cachecrab, Story Count: 1
Author: breck, Story Count: 1
Author: blini2077, Story Count: 1
Author: bauruine, Story Count: 1
Author: asymmetric, Story Count: 1
Author: arbol, Story Count: 1
Author: agomez314, Story Count: 1
Author: XzetaU8, Story Count: 1
Author: TotalCrackpot, Story Count: 1
Author: Tomte, Story Count: 1
Author: Tiberium, Story Count: 1
Author: NeilSmith2048, Story Count: 1
Author: MitPitt, Story Count: 1
Author: MBCook, Story Count: 1
Author: Kairon, Story Count: 1
Author: Gerard0, Story Count: 1
Author: GalaxySnail, Story Count: 1
Author: DustinBrett, Story Count: 1
Author: ColinWright, Story Count: 1
Author: CaliforniaKarl, Story Count: 1
Author: Bromeo, Story Count: 1
Author: Brajeshwar, Story Count: 1
Author: ArchAndStarch, Story Count: 1
